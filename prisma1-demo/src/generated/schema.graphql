type AggregateAttack {
  count: Int!
}

type AggregatePokemon {
  count: Int!
}

type AggregatePokemonAttack {
  count: Int!
}

type Attack {
  id: Int!
  name: String
  damage: String
}

type AttackConnection {
  pageInfo: PageInfo!
  edges: [AttackEdge]!
  aggregate: AggregateAttack!
}

input AttackCreateInput {
  id: Int
  name: String
  damage: String
}

input AttackCreateManyInput {
  create: [AttackCreateInput!]
  connect: [AttackWhereUniqueInput!]
}

type AttackEdge {
  node: Attack!
  cursor: String!
}

enum AttackOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  damage_ASC
  damage_DESC
}

type AttackPreviousValues {
  id: Int!
  name: String
  damage: String
}

input AttackScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  damage: String
  damage_not: String
  damage_in: [String!]
  damage_not_in: [String!]
  damage_lt: String
  damage_lte: String
  damage_gt: String
  damage_gte: String
  damage_contains: String
  damage_not_contains: String
  damage_starts_with: String
  damage_not_starts_with: String
  damage_ends_with: String
  damage_not_ends_with: String
  AND: [AttackScalarWhereInput!]
  OR: [AttackScalarWhereInput!]
  NOT: [AttackScalarWhereInput!]
}

type AttackSubscriptionPayload {
  mutation: MutationType!
  node: Attack
  updatedFields: [String!]
  previousValues: AttackPreviousValues
}

input AttackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttackWhereInput
  AND: [AttackSubscriptionWhereInput!]
  OR: [AttackSubscriptionWhereInput!]
  NOT: [AttackSubscriptionWhereInput!]
}

input AttackUpdateDataInput {
  name: String
  damage: String
}

input AttackUpdateInput {
  name: String
  damage: String
}

input AttackUpdateManyDataInput {
  name: String
  damage: String
}

input AttackUpdateManyInput {
  create: [AttackCreateInput!]
  update: [AttackUpdateWithWhereUniqueNestedInput!]
  upsert: [AttackUpsertWithWhereUniqueNestedInput!]
  delete: [AttackWhereUniqueInput!]
  connect: [AttackWhereUniqueInput!]
  set: [AttackWhereUniqueInput!]
  disconnect: [AttackWhereUniqueInput!]
  deleteMany: [AttackScalarWhereInput!]
  updateMany: [AttackUpdateManyWithWhereNestedInput!]
}

input AttackUpdateManyMutationInput {
  name: String
  damage: String
}

input AttackUpdateManyWithWhereNestedInput {
  where: AttackScalarWhereInput!
  data: AttackUpdateManyDataInput!
}

input AttackUpdateWithWhereUniqueNestedInput {
  where: AttackWhereUniqueInput!
  data: AttackUpdateDataInput!
}

input AttackUpsertWithWhereUniqueNestedInput {
  where: AttackWhereUniqueInput!
  update: AttackUpdateDataInput!
  create: AttackCreateInput!
}

input AttackWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  damage: String
  damage_not: String
  damage_in: [String!]
  damage_not_in: [String!]
  damage_lt: String
  damage_lte: String
  damage_gt: String
  damage_gte: String
  damage_contains: String
  damage_not_contains: String
  damage_starts_with: String
  damage_not_starts_with: String
  damage_ends_with: String
  damage_not_ends_with: String
  AND: [AttackWhereInput!]
  OR: [AttackWhereInput!]
  NOT: [AttackWhereInput!]
}

input AttackWhereUniqueInput {
  id: Int
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createAttack(data: AttackCreateInput!): Attack!
  updateAttack(data: AttackUpdateInput!, where: AttackWhereUniqueInput!): Attack
  updateManyAttacks(data: AttackUpdateManyMutationInput!, where: AttackWhereInput): BatchPayload!
  upsertAttack(where: AttackWhereUniqueInput!, create: AttackCreateInput!, update: AttackUpdateInput!): Attack!
  deleteAttack(where: AttackWhereUniqueInput!): Attack
  deleteManyAttacks(where: AttackWhereInput): BatchPayload!
  createPokemon(data: PokemonCreateInput!): Pokemon!
  updatePokemon(data: PokemonUpdateInput!, where: PokemonWhereUniqueInput!): Pokemon
  updateManyPokemons(data: PokemonUpdateManyMutationInput!, where: PokemonWhereInput): BatchPayload!
  upsertPokemon(where: PokemonWhereUniqueInput!, create: PokemonCreateInput!, update: PokemonUpdateInput!): Pokemon!
  deletePokemon(where: PokemonWhereUniqueInput!): Pokemon
  deleteManyPokemons(where: PokemonWhereInput): BatchPayload!
  createPokemonAttack(data: PokemonAttackCreateInput!): PokemonAttack!
  updatePokemonAttack(data: PokemonAttackUpdateInput!, where: PokemonAttackWhereUniqueInput!): PokemonAttack
  upsertPokemonAttack(where: PokemonAttackWhereUniqueInput!, create: PokemonAttackCreateInput!, update: PokemonAttackUpdateInput!): PokemonAttack!
  deletePokemonAttack(where: PokemonAttackWhereUniqueInput!): PokemonAttack
  deleteManyPokemonAttacks(where: PokemonAttackWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pokemon {
  id: ID!
  number: Int!
  name: String!
  attacks: PokemonAttack
}

type PokemonAttack {
  id: Int!
  special(where: AttackWhereInput, orderBy: AttackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attack!]
}

type PokemonAttackConnection {
  pageInfo: PageInfo!
  edges: [PokemonAttackEdge]!
  aggregate: AggregatePokemonAttack!
}

input PokemonAttackCreateInput {
  id: Int
  special: AttackCreateManyInput
}

input PokemonAttackCreateOneInput {
  create: PokemonAttackCreateInput
  connect: PokemonAttackWhereUniqueInput
}

type PokemonAttackEdge {
  node: PokemonAttack!
  cursor: String!
}

enum PokemonAttackOrderByInput {
  id_ASC
  id_DESC
}

type PokemonAttackPreviousValues {
  id: Int!
}

type PokemonAttackSubscriptionPayload {
  mutation: MutationType!
  node: PokemonAttack
  updatedFields: [String!]
  previousValues: PokemonAttackPreviousValues
}

input PokemonAttackSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonAttackWhereInput
  AND: [PokemonAttackSubscriptionWhereInput!]
  OR: [PokemonAttackSubscriptionWhereInput!]
  NOT: [PokemonAttackSubscriptionWhereInput!]
}

input PokemonAttackUpdateDataInput {
  special: AttackUpdateManyInput
}

input PokemonAttackUpdateInput {
  special: AttackUpdateManyInput
}

input PokemonAttackUpdateOneInput {
  create: PokemonAttackCreateInput
  update: PokemonAttackUpdateDataInput
  upsert: PokemonAttackUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PokemonAttackWhereUniqueInput
}

input PokemonAttackUpsertNestedInput {
  update: PokemonAttackUpdateDataInput!
  create: PokemonAttackCreateInput!
}

input PokemonAttackWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  special_every: AttackWhereInput
  special_some: AttackWhereInput
  special_none: AttackWhereInput
  AND: [PokemonAttackWhereInput!]
  OR: [PokemonAttackWhereInput!]
  NOT: [PokemonAttackWhereInput!]
}

input PokemonAttackWhereUniqueInput {
  id: Int
}

type PokemonConnection {
  pageInfo: PageInfo!
  edges: [PokemonEdge]!
  aggregate: AggregatePokemon!
}

input PokemonCreateInput {
  id: ID
  number: Int!
  name: String!
  attacks: PokemonAttackCreateOneInput
}

type PokemonEdge {
  node: Pokemon!
  cursor: String!
}

enum PokemonOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  name_ASC
  name_DESC
}

type PokemonPreviousValues {
  id: ID!
  number: Int!
  name: String!
}

type PokemonSubscriptionPayload {
  mutation: MutationType!
  node: Pokemon
  updatedFields: [String!]
  previousValues: PokemonPreviousValues
}

input PokemonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PokemonWhereInput
  AND: [PokemonSubscriptionWhereInput!]
  OR: [PokemonSubscriptionWhereInput!]
  NOT: [PokemonSubscriptionWhereInput!]
}

input PokemonUpdateInput {
  number: Int
  name: String
  attacks: PokemonAttackUpdateOneInput
}

input PokemonUpdateManyMutationInput {
  number: Int
  name: String
}

input PokemonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  attacks: PokemonAttackWhereInput
  AND: [PokemonWhereInput!]
  OR: [PokemonWhereInput!]
  NOT: [PokemonWhereInput!]
}

input PokemonWhereUniqueInput {
  id: ID
  number: Int
}

type Query {
  attack(where: AttackWhereUniqueInput!): Attack
  attacks(where: AttackWhereInput, orderBy: AttackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attack]!
  attacksConnection(where: AttackWhereInput, orderBy: AttackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttackConnection!
  pokemon(where: PokemonWhereUniqueInput!): Pokemon
  pokemons(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pokemon]!
  pokemonsConnection(where: PokemonWhereInput, orderBy: PokemonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonConnection!
  pokemonAttack(where: PokemonAttackWhereUniqueInput!): PokemonAttack
  pokemonAttacks(where: PokemonAttackWhereInput, orderBy: PokemonAttackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PokemonAttack]!
  pokemonAttacksConnection(where: PokemonAttackWhereInput, orderBy: PokemonAttackOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PokemonAttackConnection!
  node(id: ID!): Node
}

type Subscription {
  attack(where: AttackSubscriptionWhereInput): AttackSubscriptionPayload
  pokemon(where: PokemonSubscriptionWhereInput): PokemonSubscriptionPayload
  pokemonAttack(where: PokemonAttackSubscriptionWhereInput): PokemonAttackSubscriptionPayload
}
